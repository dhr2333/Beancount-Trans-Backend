"""
Django settings for project project.

Generated by 'django-admin startproject' using Django 4.0.3.

For more information on this file, see
https://docs.djangoproject.com/en/4.0/topics/settings/

For the full list of settings and their values, see
https://docs.djangoproject.com/en/4.0/ref/settings/
"""
import datetime
import os
import sys
from pathlib import Path
from dotenv import load_dotenv

# 加载 .env 文件（如果存在）
load_dotenv()


def env_to_bool(env, default):
    """环境变量转布尔值"""
    str_val = os.environ.get(env)
    return default if str_val is None else str_val.lower() in ('true', '1', 'yes')


def env_to_list(env, default=''):
    """环境变量转列表（逗号分隔）"""
    value = os.environ.get(env, default)
    return [item.strip() for item in value.split(',') if item.strip()]


# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent.parent
sys.path.insert(0, str(BASE_DIR))

# 对会话和密码进行加密和签名防止伪造，确保唯一性
SECRET_KEY = os.environ.get('DJANGO_SECRET_KEY')
if not SECRET_KEY:
    raise ValueError("DJANGO_SECRET_KEY environment variable is required")

DEBUG = env_to_bool('DJANGO_DEBUG', False)
REDIS_HOST = os.environ.get("TRANS_REDIS_HOST", "127.0.0.1")
REDIS_PORT = os.environ.get("TRANS_REDIS_PORT", "6379")
REDIS_PASSWORD = os.environ.get("TRANS_REDIS_PASSWORD", "root")

# ALLOWED_HOSTS 根据 DEBUG 模式自动配置
if DEBUG:
    ALLOWED_HOSTS = ['*']
else:
    ALLOWED_HOSTS = env_to_list('DJANGO_ALLOWED_HOSTS', 'localhost,127.0.0.1')

# CSRF 配置
CSRF_TRUSTED_ORIGINS = env_to_list('CSRF_TRUSTED_ORIGINS', 'http://localhost')
CSRF_COOKIE_SECURE = not DEBUG
CSRF_COOKIE_SAMESITE = 'Lax'
CSRF_COOKIE_HTTPONLY = True

# Application definition
INSTALLED_APPS = [  # 项目中使用的 Django 应用程序
    # 系统应用
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'django.contrib.humanize',
    'django_filters',
    'django.contrib.sites',
    'coreapi',
    'corsheaders',

    # 第三方应用
    'rest_framework',
    'rest_framework.authtoken',
    'rest_framework_simplejwt',
    'drf_spectacular',
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'allauth.socialaccount.providers.github',
    'allauth.socialaccount.providers.dummy',
    "allauth.headless",
    "allauth.usersessions",
    'dj_rest_auth',
    'dj_rest_auth.registration',
    'mptt',
    'django_celery_beat',

    # 本地应用
    'project.apps.account',
    'project.apps.fava_instances',
    'project.apps.file_manager',
    'project.apps.maps',
    'project.apps.tags',
    'project.apps.translate',
]

# 根据 DEBUG 模式决定是否包含开发专用应用
if DEBUG:
    INSTALLED_APPS.extend([
        # 'drf_spectacular_sidecar',
        # 'project.apps.users',
    ])

MIDDLEWARE = [  # 处理请求和响应的组件，允许在请求到达视图之前或在响应发送到客户端之前对其进行处理
    'corsheaders.middleware.CorsMiddleware',  # API 需要被不同域的前端应用访问时，使用此中间件来配置允许的跨域请求
    'django.middleware.security.SecurityMiddleware',  # 提供一系列安全相关的功能，生产环境强烈推荐使用
    'django.contrib.sessions.middleware.SessionMiddleware',  # 处理会话管理
    'django.middleware.common.CommonMiddleware',
    # 'django.middleware.csrf.CsrfViewMiddleware',  # 提供对跨站请求伪造（CSRF）攻击的保护，在用户表单提交时添加CSRF令牌
    'django.contrib.auth.middleware.AuthenticationMiddleware',  # 处理用户身份验证和管理
    'django.contrib.messages.middleware.MessageMiddleware',  # 处理临时消息存储，允许在不同的请求之间传递消息（如成功、错误提示等）
    'django.middleware.clickjacking.XFrameOptionsMiddleware',  # 防止点击劫持攻击，通过设置 HTTP 头来控制页面是否可以在 <iframe> 中嵌入
    'allauth.account.middleware.AccountMiddleware',
]

ROOT_URLCONF = 'project.urls'  # 指定 Django 应用的 URL 配置模块

TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',  # 模板引擎
        'DIRS': [os.path.join(BASE_DIR, 'templates')],  # 模板文件搜索目录
        'APP_DIRS': True,  # 如果为True，在每个应用的templates目录中查找模板
        'OPTIONS': {  # 额外选项
            'context_processors': [  # 上下文处理器
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'project.wsgi.application'  # WSGI 应用程序的路径，部署 Django 应用时与 WSGI 服务器（如 Gunicorn、uWSGI）进行交互

# Allauth Configuration
SITE_ID = 1  # 多站点配置，根据请求的域名加载不同的内容

# 根据 BASE_URL 动态生成重定向 URL
BASE_URL = os.environ.get('BASE_URL', 'localhost')
if BASE_URL == 'localhost':
    LOGIN_REDIRECT_URL = f'http://{BASE_URL}/api/accounts/github/login/callback/'
    LOGOUT_REDIRECT_URL = f'http://{BASE_URL}'
else:
    LOGIN_REDIRECT_URL = f'https://{BASE_URL}/api/accounts/github/login/callback/'
    LOGOUT_REDIRECT_URL = f'https://{BASE_URL}'

SOCIALACCOUNT_ADAPTER = 'allauth.socialaccount.adapter.DefaultSocialAccountAdapter'
SOCIALACCOUNT_AUTO_SIGNUP = True
SOCIALACCOUNT_EMAIL_AUTHENTICATION = True
SOCIALACCOUNT_EMAIL_AUTHENTICATION_AUTO_CONNECT = False
SOCIALACCOUNT_STORE_TOKENS = True
SOCIALACCOUNT_LOGIN_ON_GET = False

# OAuth 配置（使用环境变量）
GITHUB_CLIENT_ID = os.environ.get('GITHUB_CLIENT_ID', '')
GITHUB_CLIENT_SECRET = os.environ.get('GITHUB_CLIENT_SECRET', '')
GOOGLE_CLIENT_ID = os.environ.get('GOOGLE_CLIENT_ID', '')
GOOGLE_CLIENT_SECRET = os.environ.get('GOOGLE_CLIENT_SECRET', '')

# Social Account Providers Configuration
SOCIALACCOUNT_PROVIDERS = {
    'dummy': {
    },
    'google': {
        'APPS': [
            {
                "client_id": GOOGLE_CLIENT_ID,
                "secret": GOOGLE_CLIENT_SECRET,
                "key": "",
            },
        ],
        'SCOPE': [
            'profile',
            'email',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        },
        'METHOD': 'oauth2',
        'VERIFIED_EMAIL': False,
        'OAUTH_PKCE_ENABLED': True,
        'VERSION': 'v3',
    },
    'github': {
        'APPS': [
            {
                "client_id": GITHUB_CLIENT_ID,
                "secret": GITHUB_CLIENT_SECRET,
                "key": "",
            },
        ],
        'SCOPE': [
            'user',
            'repo',
            'read:org',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        },
        'METHOD': 'oauth2',
        'VERIFIED_EMAIL': False,
        'OAUTH_PKCE_ENABLED': True,
        'VERSION': 'v3',
    },
}

# Allauth Headless
# HEADLESS_ONLY = True  # 设置allauth为无头服务
# HEADLESS_TOKEN_STRATEGY = "allauth.headless.tokens.sessions.SessionTokenStrategy"
HEADLESS_TOKEN_STRATEGY = "project.utils.token.JWTTokenStrategy"
HEADLESS_ADAPTER = "allauth.headless.adapter.DefaultHeadlessAdapter"
HEADLESS_FRONTEND_URLS = {
    "account_confirm_email": f"{LOGOUT_REDIRECT_URL}/api/accounts/verify-email/{{key}}",
    "account_reset_password": f"{LOGOUT_REDIRECT_URL}/api/accounts/password/reset",
    "account_reset_password_from_key": f"{LOGOUT_REDIRECT_URL}/api/accounts/password/reset/key/{{key}}",
    "account_signup": f"{LOGOUT_REDIRECT_URL}/api/accounts/signup",
    "socialaccount_login_error": f"{LOGOUT_REDIRECT_URL}/api/accounts/google/login/callback",
}

# MFA_SUPPORTED_TYPES = ["totp", "recovery_codes", "webauthn"]
# MFA_PASSKEY_LOGIN_ENABLED = True

# Authentication Backends
AUTHENTICATION_BACKENDS = [  # 通过配置不同的认证后端，可以支持多种身份验证方式
    # Needed to login by username in Django admin, regardless of `allauth`
    'django.contrib.auth.backends.ModelBackend',

    # `allauth` specific authentication methods, such as login by email
    'allauth.account.auth_backends.AuthenticationBackend',
]

# 配置 Django Allauth
ACCOUNT_LOGIN_METHODS = {'username'}
ACCOUNT_SIGNUP_FIELDS = ['email', 'username*', 'password1*', 'password2*']
ACCOUNT_EMAIL_VERIFICATION = 'optional'  # 用户可以选择是否验证电子邮件,none mandatory optional
ACCOUNT_LOGOUT_ON_PASSWORD_CHANGE = False  # 用户在更改密码时是否自动注销
ACCOUNT_LOGIN_BY_CODE_ENABLED = True  # 允许用户通过输入代码（通常是通过邮箱或短信发送的）进行登录，默认为False

# JWT 配置（根据环境变量配置）
JWT_ACCESS_TOKEN_HOURS = int(os.environ.get('JWT_ACCESS_TOKEN_HOURS', '1' if not DEBUG else '72'))

# 配置用于 JWT 的 REST_AUTH
REST_AUTH = {
    'USE_JWT': True,
    "JWT_AUTH_HTTPONLY": False,
    'JWT_AUTH_COOKIE': 'beancount-trans-auth',
    'JWT_AUTH_REFRESH_COOKIE': 'beancount-trans-refresh-token',
    'JWT_AUTH_COOKIE_USE_CSRF': False,
    'JWT_AUTH_COOKIE_ENFORCE_CSRF_ON_UNAUTHENTICATED': False,
    'JWT_ACCESS_TOKEN_LIFETIME': datetime.timedelta(hours=JWT_ACCESS_TOKEN_HOURS),
    'JWT_REFRESH_TOKEN_LIFETIME': datetime.timedelta(days=3),
    'JWT_ROTATE_REFRESH_TOKENS': False,
    'JWT_BLACKLIST_AFTER_ROTATION': True,
}

# CORS Configuration
CORS_ALLOW_CREDENTIALS = True  # 是否允许跨域请求中包含凭据(cookies、HTTP 认证信息)
SESSION_COOKIE_SAMESITE = 'Lax'
CORS_ALLOW_METHODS = (  # 指定允许的 HTTP 方法用于跨域请求
    'DELETE',
    'GET',
    'OPTIONS',
    'PATCH',
    'POST',
    'PUT',
    'VIEW',
)
CORS_ALLOW_HEADERS = (  # 指定允许的 HTTP 请求头用于跨域请求
    'XMLHttpRequest',
    'X_FILENAME',
    'accept-encoding',
    'authorization',
    'content-type',
    'dnt',
    'origin',
    'user-agent',
    'x-csrftoken',
    'x-requested-with',
    'Pragma',
)

# CORS 配置根据 DEBUG 模式自动调整
if DEBUG:
    CORS_ALLOW_ALL_ORIGINS = True
    CORS_ALLOWED_ORIGINS = env_to_list('CORS_ALLOWED_ORIGINS',
        'http://127.0.0.1:5173,http://localhost:5173')
else:
    CORS_ALLOWED_ORIGINS = env_to_list('CORS_ALLOWED_ORIGINS')
    if not CORS_ALLOWED_ORIGINS:
        raise ValueError("CORS_ALLOWED_ORIGINS is required in production")

# Security Settings
SECURE_PROXY_SSL_HEADER = ('HTTP_X_FORWARDED_PROTO', 'https')

# Database Configuration
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.postgresql',
        'NAME': os.environ.get('TRANS_POSTGRESQL_DATABASE', 'beancount-trans'),
        'USER': os.environ.get('TRANS_POSTGRESQL_USER', 'root'),
        'PASSWORD': os.environ.get('TRANS_POSTGRESQL_PASSWORD', 'root'),
        'HOST': os.environ.get('TRANS_POSTGRESQL_HOST', '127.0.0.1'),
        'PORT': os.environ.get('TRANS_POSTGRESQL_PORT', '5432'),
        'TIME_ZONE': 'Asia/Shanghai',
    }
}

# Cache Configuration
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': f'redis://{REDIS_HOST}:{REDIS_PORT}/0',
        'OPTIONS':
            {'password': REDIS_PASSWORD},
    },
    'session': {
        'BACKEND': 'django.core.cache.backends.redis.RedisCache',
        'LOCATION': f'redis://{REDIS_HOST}:{REDIS_PORT}/1',
        'OPTIONS':
            {'password': REDIS_PASSWORD},
    },
}
SESSION_ENGINE = "django.contrib.sessions.backends.cache"  # 会话存储后端（数据库、缓存、文件系统）
SESSION_CACHE_ALIAS = "session"  # 会话的缓存别名，适用于使用缓存存储会话时

# Password validation
AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },  # 检查密码是否与用户的其他属性（如用户名或电子邮件）太相似
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },  # 确保密码至少达到指定的最小长度
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },  # 防止使用常见或易猜测的密码
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },  # 阻止仅使用数字的密码
]

# Internationalization
LANGUAGE_CODE = 'zh-hans'
TIME_ZONE = 'Asia/Shanghai'
USE_I18N = True  # 国际化（i18n）功能
USE_TZ = True  # 时区

# Static files (CSS, JavaScript, Images)
STATIC_ROOT = os.path.join(BASE_DIR, 'collectstatic')  # 使用 python manage.py collectstatic 命令时，所有静态文件将被复制到此目录
STATIC_URL = 'static/'  # 静态文件URL前缀
STATICFILES_DIRS = [  # 指定额外的静态文件目录，收集静态文件时会包含这些目录
    os.path.join(BASE_DIR, 'static'),
]
MEDIA_URL = 'media/'  # 访问媒体文件的 URL 前缀，通常用于用户上传的文件
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')  # 用户上传文件的存储目录

# Default auto field
DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'  # 模型的默认主键字段类型，AutoField or BigAutoField

# REST Framework Settings
REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': (  # 默认的身份验证类
        # 'dj_rest_auth.jwt_auth.JWTCookieAuthentication',
        'rest_framework_simplejwt.authentication.JWTAuthentication',
        # 'rest_framework.authentication.BasicAuthentication',
        'rest_framework.authentication.SessionAuthentication',
    ),
    'DEFAULT_PERMISSION_CLASSES': (  # 默认的权限类
        # 'rest_framework.permissions.AllowAny',
        'rest_framework.permissions.IsAuthenticated',
    ),
    'DEFAULT_THROTTLE_CLASSES': (  # 请求速率限制
        'rest_framework.throttling.AnonRateThrottle',
        'rest_framework.throttling.UserRateThrottle'
    ),
    'DEFAULT_THROTTLE_RATES': {
        'anon': '10000/minute',
        'user': '10000/minute'
    },
    'DEFAULT_FILTER_BACKENDS': (  # 过滤后端，允许使用 Django Filter 进行查询
        'django_filters.rest_framework.DjangoFilterBackend',
    ),
    # 'DEFAULT_PAGINATION_CLASS': 'rest_framework.pagination.PageNumberPagination',  # 分页
    # 'PAGE_SIZE': 200,
    'EXCEPTION_HANDLER': 'project.utils.exceptions.custom_exception_handler',  # 自定义异常处理器
    'DEFAULT_SCHEMA_CLASS': 'drf_spectacular.openapi.AutoSchema',  # 自动生成 API 文档的模式类
}

# DRF Spectacular Settings
SPECTACULAR_SETTINGS = {
    'TITLE': 'Beancount-Trans API',
    'DESCRIPTION': 'Beancount交易记录转换和管理系统的API文档',
    'VERSION': '1.0.0',
    'SERVE_INCLUDE_SCHEMA': False,
    'COMPONENT_SPLIT_REQUEST': True,
    'SCHEMA_PATH_PREFIX': '/api/',
    'SWAGGER_UI_SETTINGS': {
        'deepLinking': True,
        'persistAuthorization': True,
        'displayOperationId': True,
    },
    'REDOC_UI_SETTINGS': {
        'hideDownloadButton': False,
        'hideHostname': False,
        'hideLoading': False,
        'hideSingleRequestSampleTab': False,
        'expandResponses': '200,201',
        'jsonSampleExpandLevel': 2,
    },
    'SECURITY': [
        {
            'Bearer': []
        }
    ]
}

# Logging Configuration
LOGGING = {
    'version': 1,
    'disable_existing_loggers': False,  # 当设置为 False 时，保留已存在的日志记录器
    'root': {
        'level': 'INFO',  # 指定根日志记录器的日志级别，INFO 表示记录信息级别及以上的日志
        'handlers': ['console', 'log_file'],  # 指定该记录器使用的处理器（handlers）
    },
    'formatters': {
        'verbose': {
            'format': '[%(asctime)s] %(levelname)s [%(name)s.%(funcName)s:%(lineno)d %(module)s] %(message)s',
        },  # 详细格式，包括时间戳、日志级别、模块名、函数名和行号
        'simple': {
            'format': '%(levelname)s [%(name)s.%(funcName)s:%(lineno)d %(module)s] %(message)s',
        }  # 简单格式，包含日志级别、模块名、函数名和行号
    },
    'filters': {
        'require_debug_false': {
            '()': 'django.utils.log.RequireDebugFalse',
        },  # 用于在 DEBUG 模式关闭时记录日志
        'require_debug_true': {
            '()': 'django.utils.log.RequireDebugTrue',
        },  # 用于在 DEBUG 模式开启时记录日志
    },
    'handlers': {
        'log_file': {
            'level': 'INFO',
            'class': 'logging.handlers.RotatingFileHandler',  # RotatingFileHandler，支持日志轮换
            'filename': os.path.join(BASE_DIR, 'logs/beancount-trans.log'),  # 日志文件的保存路径
            'maxBytes': 10 * 1024 * 1024,  # 日志文件的最大字节数，达到后将进行轮换
            'backupCount': 10,  # 保留的备份日志文件数量
            'formatter': 'verbose',
        },
        'console': {
            'level': 'DEBUG',
            'filters': ['require_debug_true'],  # 应用过滤器，确保只有在 DEBUG 模式下才记录
            'class': 'logging.StreamHandler',  # StreamHandler，用于输出到标准输出
            'formatter': 'simple'
        },
    },
    'loggers': {  # 特定的日志记录器
        'beancount-trans': {  # 记录来自 beancount-trans 模块的日志，并使用 log_file 和 console 处理器
            'handlers': ['log_file', 'console'],
            'level': 'INFO',
            'propagate': True,  # 日志会传递到父日志记录器
        },
        'allauth': {  # 专门用于 Allauth 模块，记录级别为 DEBUG，仅输出到控制台，不向上游传播
            'handlers': ['console'],
            'level': 'DEBUG',
            'propagate': False,
        },
    }
}

# 存储类型配置 (minio, oss, s3)
STORAGE_TYPE = os.environ.get('STORAGE_TYPE', 'minio')

# MinIO配置
MINIO_CONFIG = {
    'ENDPOINT': os.environ.get('MINIO_ENDPOINT', '127.0.0.1:9000'),
    'ACCESS_KEY': os.environ.get('MINIO_ACCESS_KEY', 'minioadmin'),
    'SECRET_KEY': os.environ.get('MINIO_SECRET_KEY', 'minioadmin'),
    'BUCKET_NAME': os.environ.get('MINIO_BUCKET_NAME', 'beancount-trans'),
    'USE_HTTPS': env_to_bool('MINIO_USE_HTTPS', False)
}

# 阿里云OSS配置
OSS_CONFIG = {
    'ENDPOINT': os.environ.get('OSS_ENDPOINT', 'oss-cn-hangzhou.aliyuncs.com'),
    'ACCESS_KEY_ID': os.environ.get('OSS_ACCESS_KEY_ID', ''),
    'ACCESS_KEY_SECRET': os.environ.get('OSS_ACCESS_KEY_SECRET', ''),
    'BUCKET_NAME': os.environ.get('OSS_BUCKET_NAME', 'beancount-trans'),
    'REGION': os.environ.get('OSS_REGION', 'cn-hangzhou')
}

# S3配置 (通用S3兼容存储)
S3_CONFIG = {
    'ENDPOINT_URL': os.environ.get('S3_ENDPOINT_URL', 'https://s3.amazonaws.com'),
    'ACCESS_KEY_ID': os.environ.get('S3_ACCESS_KEY_ID', ''),
    'SECRET_ACCESS_KEY': os.environ.get('S3_SECRET_ACCESS_KEY', ''),
    'BUCKET_NAME': os.environ.get('S3_BUCKET_NAME', 'beancount-trans'),
    'REGION': os.environ.get('S3_REGION', 'us-east-1'),
    'USE_SSL': env_to_bool('S3_USE_SSL', True),
    'VERIFY_SSL': env_to_bool('S3_VERIFY_SSL', True)
}

# Traefik 配置
TRAEFIK_NETWORK = os.environ.get('TRAEFIK_NETWORK', 'shared-network')
FAVA_IMAGE = os.environ.get('FAVA_IMAGE', 'harbor.dhr2333.cn/beancount-trans-assets:develop')
CERTRESOLVER = os.environ.get('CERTRESOLVER', 'alicloud-dns')

# 容器生命周期 (1小时)
FAVA_CONTAINER_LIFETIME = datetime.timedelta(seconds=3600)

# Celery 配置
CELERY_BROKER_URL = f'redis://default:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/2'
CELERY_RESULT_BACKEND = f'redis://default:{REDIS_PASSWORD}@{REDIS_HOST}:{REDIS_PORT}/3'
CELERY_BEAT_SCHEDULE = {
    'cleanup_fava_containers': {
        'task': 'fava_instances.tasks.cleanup_fava_containers',
        'schedule': datetime.timedelta(seconds=60),  # 每1分钟执行一次清理任务
    },
}

CELERY_BEAT_SCHEDULER = 'django_celery_beat.schedulers:DatabaseScheduler'

# Bean文件相关配置
ASSETS_BASE_PATH = BASE_DIR / 'Assets'
ASSETS_HOST_PATH = os.environ.get('ASSETS_HOST_PATH', str(ASSETS_BASE_PATH))